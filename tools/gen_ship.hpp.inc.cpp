// std
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <format>
#include <fstream>
#include <print>
#include <string>
#include <string_view>
#include <vector>

// glz
#include <glaze/json.hpp>

namespace kcv::tools {

// JSON解析のために, kcv::kcsapi::api_mst_ship型およびその型で明示的特殊化をしたkcv::read_jsonが必要となる.
// しかし, それらに依存すると依存解決が困難となるため, 不完全で簡易なapi_mst_ship型を改めてここに定義する.
// このままではJSON解析時にunknoen_keyeエラーが発生するため, これを抑制するように設定する.
constexpr auto opts = glz::opts{.error_on_unknown_keys = false};

struct api_mst_ship_value_t final {
    std::int32_t api_id;
    std::string_view api_name;
};

using api_mst_ship = std::vector<api_mst_ship_value_t>;

}  // namespace kcv::tools

int main() {
    const auto src = std::filesystem::path{"./assets/kcsapi/api_start2/api_mst_ship.json"};
    const auto dst = std::filesystem::path{"./library/include/kcv/core/constants/ship.hpp.inc"};

    auto buffer = std::string{};
    buffer.resize_and_overwrite(std::filesystem::file_size(src), [&src](char* data, std::size_t size) -> std::size_t {
        std::ifstream{src}.read(data, size);
        return size;
    });

    auto data = kcv::tools::api_mst_ship{};
    data.reserve(2000uz);
    if (const auto error = glz::read<kcv::tools::opts>(data, buffer); error) {
        std::println(stderr, "{}", glz::format_error(error, buffer));
        return EXIT_FAILURE;
    }

    if (not std::ranges::is_sorted(data, {}, &kcv::tools::api_mst_ship::value_type::api_id)) {
        std::ranges::sort(data, {}, &kcv::tools::api_mst_ship::value_type::api_id);
    }

    auto ofs = std::ofstream{dst};
    ofs << "// generated by ./tools/gen_ship.hpp.inc.cpp" << '\n';
    ofs << "// {api_id, api_name}" << '\n';
    for (const auto& e : data) {
        ofs << std::format("{{{}, {:?}}},", e.api_id, e.api_name) << '\n';
    }
}